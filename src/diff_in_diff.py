# -*- coding: utf-8 -*-
"""diff and diff.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1eVKgRl7nZZPvk7Q1sZh3y-fCRB3Q_hzn
"""

import pandas as pd
from IPython.display import display, HTML

#url = "https://raw.githubusercontent.com/rayangannoun-png/Project-Datascience/refs/heads/main/Final_dataset.csv"

url = "https://raw.githubusercontent.com/rayangannoun-png/Project-Datascience/refs/heads/main/Final_dataset_v.csv"


# Lecture robuste (essaie ; puis ,)
try:
    df_DD = pd.read_csv(url, sep=";", engine="python")
    if df_DD.shape[1] == 1:  # mauvais sep
        df_DD = pd.read_csv(url, sep=",", engine="python")
except Exception:
    df_DD = pd.read_csv(url, sep=None, engine="python")

print("Shape (rows, cols):", df_DD.shape)
print("Columns:", list(df_DD.columns))

# Display (100 premières lignes)
html = df_DD.head(100).to_html(index=False)
display(HTML(html))

import pandas as pd

# colonne exacte dans ton CSV
tour_col = "tourists ['000]"

df_DD[tour_col] = pd.to_numeric(df_DD[tour_col], errors="coerce") * 1000

print(f"Done: {tour_col} * 1000")
df_DD[[tour_col]].head()

import pandas as pd

# --- détecte les colonnes (robuste) ---
country_col = next((c for c in df_DD.columns if c.strip().lower() in ["country","pays"]), None)
year_col    = next((c for c in df_DD.columns if c.strip().lower() in ["year","année","annee"]), None)
deaths_col  = next((c for c in df_DD.columns if "death" in c.strip().lower()), None)

if country_col is None or year_col is None or deaths_col is None:
    raise KeyError(f"Colonnes introuvables. Trouvé: country={country_col}, year={year_col}, deaths={deaths_col}")

# --- numeric + top 10% ---
deaths_num = pd.to_numeric(df_DD[deaths_col], errors="coerce")
q97 = deaths_num.quantile(0.97)

top10 = (
    df_DD.loc[deaths_num >= q97, [country_col, year_col, deaths_col]]
      .assign(_deaths_num=deaths_num)
      .sort_values("_deaths_num", ascending=False)
      .drop(columns="_deaths_num")
      .reset_index(drop=True)
)

print(f"Seuil 90e percentile ({deaths_col}) =", q97)
print("Nb obs dans top 3% =", len(top10))

top10.head(72)  # affiche les 50 plus gros du top 10%

# Pays uniques (depuis ton tableau top10 déjà créé)
pays_uniques = (
    top10[country_col]
    .dropna()
    .astype(str)
    .drop_duplicates()
    .sort_values()
    .reset_index(drop=True)
)

print("Nb pays uniques:", len(pays_uniques))
display(pays_uniques)

import pandas as pd
import numpy as np
from IPython.display import display

# =========================
# 2D table: rows=countries, cols=Year, values=annual tourists growth rate (in %)
# + highlight (fluorescent) the (country, year) cells where deaths are in your top 3%
# =========================

countries = [
    "Angola","Bangladesh","Belgium","Brazil","Burkina Faso","China",
    "Democratic Republic of the Congo","El Salvador","Ethiopia","France",
    "Germany","Haiti","India","Italy","Malawi","Myanmar","Nepal",
    "Netherlands","Philippines","Portugal","Sierra Leone","Spain",
    "Sri Lanka","Thailand","United States of America"
]

# Years (top 3% deaths) per country (from your pasted list)
years_by_country = {
    "Angola": {2006},
    "Bangladesh": {2002, 2004, 2007},
    "Belgium": {2003, 2006},
    "Brazil": {2011},
    "Burkina Faso": {2001, 2003, 2007},
    "China": {2002, 2003, 2005, 2006, 2007, 2008, 2010, 2013, 2014, 2016},
    "Democratic Republic of the Congo": {2002, 2018, 2019},
    "El Salvador": {2001},
    "Ethiopia": {2006},
    "France": {2003, 2006, 2015, 2019},
    "Germany": {2003},
    "Haiti": {2004, 2010},
    "India": {2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2013, 2014, 2015, 2016, 2017, 2018, 2019},
    "Italy": {2003},
    "Malawi": {2001},
    "Myanmar": {2008},
    "Nepal": {2015},
    "Netherlands": {2003, 2006},
    "Philippines": {2004, 2006, 2008, 2009, 2010, 2011, 2012, 2013, 2019},
    "Portugal": {2003},
    "Sierra Leone": {2014, 2017},
    "Spain": {2003},
    "Sri Lanka": {2004},
    "Thailand": {2004},
    "United States of America": {2005},
}

# --- detect columns robustly ---
country_col = next((c for c in df_DD.columns if c.strip().lower() == "country"), None)
year_col    = next((c for c in df_DD.columns if c.strip().lower() == "year"), None)
tour_col    = next((c for c in df_DD.columns if "tourist" in c.strip().lower()), None)

if country_col is None or year_col is None or tour_col is None:
    raise KeyError(f"Colonnes introuvables. Trouvé: country={country_col}, year={year_col}, tourists={tour_col}")

tmp = df_DD[[country_col, year_col, tour_col]].copy()
tmp = tmp[tmp[country_col].isin(countries)].copy()

tmp[year_col] = pd.to_numeric(tmp[year_col], errors="coerce").astype("Int64")
tmp[tour_col] = pd.to_numeric(tmp[tour_col], errors="coerce")

tmp = tmp.dropna(subset=[country_col, year_col, tour_col]).sort_values([country_col, year_col])

# Growth rate: (tourists_t / tourists_{t-1}) - 1  (in %)
tmp["tourists_growth_pct"] = tmp.groupby(country_col)[tour_col].pct_change() * 100

# Pivot 2D table
growth_table = (
    tmp.pivot(index=country_col, columns=year_col, values="tourists_growth_pct")
       .reindex(countries)
       .sort_index(axis=1)
)

# --- Styling: fluorescent highlight for (country,year) pairs in top 3% deaths ---
def highlight_top3(df):
    styles = pd.DataFrame("", index=df.index, columns=df.columns)
    for c, yrs in years_by_country.items():
        if c in styles.index:
            for y in yrs:
                if y in styles.columns:
                    styles.loc[c, y] = "background-color: #CCFF00; color: black; font-weight: 700;"
    return styles

styled = (
    growth_table.style
      .format(lambda v: "" if pd.isna(v) else f"{v:.2f}%")
      .apply(highlight_top3, axis=None)
)

display(styled)

import pandas as pd
import numpy as np
from IPython.display import display

# =========================
# manual filter
# =========================

countries = [
    "Angola","Bangladesh","Belgium","Brazil","Burkina Faso","China","Ethiopia","France","Haiti","India","Myanmar","Nepal",
    "Netherlands","Philippines","Sierra Leone","United States of America"
]

# Years (top 3% deaths) per country (from your pasted list)
years_by_country = {
    "Angola": {2006},
    "Bangladesh": {2007},
    "Belgium": {2006},
    "Brazil": {2011},
    "Burkina Faso": {2007},
    "China": {2006, 2007, 2008, 2010, 2013, 2014, 2016},
    "Ethiopia": {2006},
    "France": {2006, 2015},
    "Haiti": {2010},
    "India": {2006, 2007, 2008, 2009, 2010, 2011, 2013, 2014, 2015, 2016},
    "Myanmar": {2008},
    "Nepal": {2015},
    "Netherlands": {2006},
    "Philippines": {2006, 2008, 2009, 2010, 2011, 2012, 2013, 2019},
    "Sierra Leone": {2014, 2017},
    "United States of America": {2005},
}

# --- detect columns robustly ---
country_col = next((c for c in df_DD.columns if c.strip().lower() == "country"), None)
year_col    = next((c for c in df_DD.columns if c.strip().lower() == "year"), None)
tour_col    = next((c for c in df_DD.columns if "tourist" in c.strip().lower()), None)

if country_col is None or year_col is None or tour_col is None:
    raise KeyError(f"Colonnes introuvables. Trouvé: country={country_col}, year={year_col}, tourists={tour_col}")

tmp = df_DD[[country_col, year_col, tour_col]].copy()
tmp = tmp[tmp[country_col].isin(countries)].copy()

tmp[year_col] = pd.to_numeric(tmp[year_col], errors="coerce").astype("Int64")
tmp[tour_col] = pd.to_numeric(tmp[tour_col], errors="coerce")

tmp = tmp.dropna(subset=[country_col, year_col, tour_col]).sort_values([country_col, year_col])

# Growth rate: (tourists_t / tourists_{t-1}) - 1  (in %)
tmp["tourists_growth_pct"] = tmp.groupby(country_col)[tour_col].pct_change() * 100

# Pivot 2D table
growth_table = (
    tmp.pivot(index=country_col, columns=year_col, values="tourists_growth_pct")
       .reindex(countries)
       .sort_index(axis=1)
)

# --- Styling: fluorescent highlight for (country,year) pairs in top 3% deaths ---
def highlight_top3(df):
    styles = pd.DataFrame("", index=df.index, columns=df.columns)
    for c, yrs in years_by_country.items():
        if c in styles.index:
            for y in yrs:
                if y in styles.columns:
                    styles.loc[c, y] = "background-color: #CCFF00; color: black; font-weight: 700;"
    return styles

styled = (
    growth_table.style
      .format(lambda v: "" if pd.isna(v) else f"{v:.2f}%")
      .apply(highlight_top3, axis=None)
)

display(styled)

import pandas as pd

countries = [
    "Angola","Bangladesh","Belgium","Brazil","Burkina Faso","China","Ethiopia","France","Haiti","India","Myanmar","Nepal",
    "Netherlands","Philippines","Sierra Leone","United States of America"
]

years_by_country = {
    "Angola": {2006},
    "Bangladesh": {2007},
    "Belgium": {2006},
    "Brazil": {2011},
    "Burkina Faso": {2007},
    "China": {2006, 2007, 2008, 2010, 2013, 2014, 2016},
    "Ethiopia": {2006},
    "France": {2006, 2015},
    "Haiti": {2010},
    "India": {2006, 2007, 2008, 2009, 2010, 2011, 2013, 2014, 2015, 2016},
    "Myanmar": {2008},
    "Nepal": {2015},
    "Netherlands": {2006},
    "Philippines": {2006, 2008, 2009, 2010, 2011, 2012, 2013, 2019},
    "Sierra Leone": {2014, 2017},
    "United States of America": {2005},
}

PRE_START = 2002

first_yellow_year = {c: min(years_by_country[c]) for c in countries}

pre_period_table = (
    pd.DataFrame({
        "country": countries,
        "pre_start": [PRE_START] * len(countries),
        "first_yellow_year": [first_yellow_year[c] for c in countries],
    })
    .sort_values(["first_yellow_year", "country"])
    .reset_index(drop=True)
)

pre_period_table

import pandas as pd
import numpy as np

# =========================
# For each treated country:
# find TOP_K best-matching control countries (rest of dataset)
# based on tourists growth rates over PRE (2002 -> first_yellow_year-1)
# Criterion: lowest MSE on overlapping pre-years
# + ADD for each (treated, matched_control):
#   - control_deaths_pre_total  : sum deaths in PRE window
#   - control_deaths_post_total : sum deaths in POST window (4 years)
#   - control_deaths_pre_post_total
# =========================

PRE_START = 2002
TOP_K = 5
MIN_OVERLAP_YEARS = 5
POST_YEARS = 4  # post = treat_year ... treat_year+3

# --- detect columns robustly ---
country_col = next((c for c in df_DD.columns if c.strip().lower() == "country"), None)
year_col    = next((c for c in df_DD.columns if c.strip().lower() == "year"), None)
tour_col    = next((c for c in df_DD.columns if "tourist" in c.strip().lower()), None)
deaths_col  = next((c for c in df_DD.columns if "death" in c.strip().lower()), None)

if country_col is None or year_col is None or tour_col is None or deaths_col is None:
    raise KeyError(
        f"Colonnes introuvables. Trouvé: country={country_col}, year={year_col}, tourists={tour_col}, deaths={deaths_col}"
    )

# --- build growth panel for ALL countries ---
dfg = df_DD[[country_col, year_col, tour_col]].copy()
dfg[year_col] = pd.to_numeric(dfg[year_col], errors="coerce").astype("Int64")
dfg[tour_col] = pd.to_numeric(dfg[tour_col], errors="coerce")
dfg = dfg.dropna(subset=[country_col, year_col, tour_col]).sort_values([country_col, year_col])

dfg["growth_pct"] = dfg.groupby(country_col)[tour_col].pct_change() * 100

growth_wide = (
    dfg.pivot(index=country_col, columns=year_col, values="growth_pct")
       .sort_index(axis=1)
)

# --- deaths table for fast sums ---
dd_deaths = df_DD[[country_col, year_col, deaths_col]].copy()
dd_deaths[year_col]   = pd.to_numeric(dd_deaths[year_col], errors="coerce").astype("Int64")
dd_deaths[deaths_col] = pd.to_numeric(dd_deaths[deaths_col], errors="coerce")
dd_deaths = dd_deaths.dropna(subset=[country_col, year_col])

def sum_deaths(country, y0, y1):
    m = (dd_deaths[country_col] == country) & (dd_deaths[year_col] >= y0) & (dd_deaths[year_col] <= y1)
    return float(dd_deaths.loc[m, deaths_col].fillna(0).sum())

treated_countries = countries[:]  # your list
all_countries = growth_wide.index.astype(str).tolist()

# candidates = all other countries in dataset (exclude treated list)
candidate_countries = [c for c in all_countries if c not in set(treated_countries)]

# treatment year = first yellow year
first_yellow_year = {c: min(years_by_country[c]) for c in treated_countries}

results = []

for tc in treated_countries:
    if tc not in growth_wide.index:
        continue

    t_year = int(first_yellow_year[tc])
    pre_years = [y for y in growth_wide.columns if (pd.notna(y) and PRE_START <= int(y) <= (t_year - 1))]
    if len(pre_years) == 0:
        continue

    tv = growth_wide.loc[tc, pre_years]

    matches = []
    for cc in candidate_countries:
        if cc not in growth_wide.index:
            continue

        cv = growth_wide.loc[cc, pre_years]

        mask = (~tv.isna()) & (~cv.isna())
        n = int(mask.sum())

        min_overlap = min(MIN_OVERLAP_YEARS, len(pre_years))
        if n < min_overlap:
            continue

        diff = (tv[mask].astype(float) - cv[mask].astype(float))
        mse = float(np.mean(diff**2))

        corr = np.nan
        if n >= 2:
            corr = float(np.corrcoef(tv[mask].astype(float), cv[mask].astype(float))[0, 1])

        matches.append((cc, n, mse, corr))

    matches.sort(key=lambda x: x[2])  # lower mse = better
    top = matches[:TOP_K]

    pre_end = t_year - 1
    post_start = t_year
    post_end = t_year + (POST_YEARS - 1)

    for rank, (cc, n, mse, corr) in enumerate(top, start=1):
        # deaths totals for CONTROL country over the windows of the treated country
        control_pre = sum_deaths(cc, PRE_START, pre_end)
        control_post = sum_deaths(cc, post_start, post_end)

        results.append({
            "treated_country": tc,
            "treat_year": t_year,

            "pre_start": PRE_START,
            "pre_end": pre_end,
            "post_start": post_start,
            "post_end": post_end,

            "rank": rank,
            "matched_country": cc,
            "overlap_years": n,
            "mse": mse,
            "corr": corr,

            "control_deaths_pre_total": control_pre,
            "control_deaths_post_total": control_post,
            "control_deaths_pre_post_total": control_pre + control_post,
        })

matches_df = (
    pd.DataFrame(results)
      .sort_values(["treated_country", "rank"])
      .reset_index(drop=True)
)

matches_df

import pandas as pd
import numpy as np

# =========================
# Average deaths per country + top 10% and bottom 10%
# =========================

# detect columns
country_col = next((c for c in df_DD.columns if c.strip().lower() == "country"), None)
deaths_col  = next((c for c in df_DD.columns if "death" in c.strip().lower()), None)

if country_col is None or deaths_col is None:
    raise KeyError(f"Colonnes introuvables. Trouvé: country={country_col}, deaths={deaths_col}")

tmp = df_DD[[country_col, deaths_col]].copy()
tmp[deaths_col] = pd.to_numeric(tmp[deaths_col], errors="coerce")
tmp = tmp.dropna(subset=[country_col, deaths_col])

# mean deaths per country
mean_deaths = (
    tmp.groupby(country_col, as_index=False)[deaths_col]
       .mean()
       .rename(columns={deaths_col: "mean_deaths"})
)

# thresholds
q90 = mean_deaths["mean_deaths"].quantile(0.90)
q10 = mean_deaths["mean_deaths"].quantile(0.10)

top10 = mean_deaths[mean_deaths["mean_deaths"] >= q90].sort_values("mean_deaths", ascending=False).reset_index(drop=True)
bottom10 = mean_deaths[mean_deaths["mean_deaths"] <= q10].sort_values("mean_deaths", ascending=True).reset_index(drop=True)

print("Nb countries:", len(mean_deaths))
print("90th percentile (top 10% threshold):", q90)
print("10th percentile (bottom 10% threshold):", q10)

print("\nTOP 10% (highest mean deaths):")
display(top10)

print("\nBOTTOM 10% (lowest mean deaths):")
display(bottom10)

import pandas as pd
from IPython.display import display, HTML

# =========================
# Ranking of ALL countries by mean deaths (scrollable)
# =========================

# --- detect columns robustly ---
country_col = next((c for c in df_DD.columns if c.strip().lower() == "country"), None)
deaths_col  = next((c for c in df_DD.columns if "death" in c.strip().lower()), None)

if country_col is None or deaths_col is None:
    raise KeyError(f"Colonnes introuvables. Trouvé: country={country_col}, deaths={deaths_col}")

tmp = df_DD[[country_col, deaths_col]].copy()
tmp[deaths_col] = pd.to_numeric(tmp[deaths_col], errors="coerce")
tmp = tmp.dropna(subset=[country_col, deaths_col])

ranking = (
    tmp.groupby(country_col, as_index=False)[deaths_col]
       .mean()
       .rename(columns={deaths_col: "mean_deaths"})
       .sort_values("mean_deaths", ascending=False)
       .reset_index(drop=True)
)

ranking.insert(0, "rank", ranking.index + 1)

# scrollable display
html = ranking.to_html(index=False)
display(HTML(f"""
<div style="max-height:500px; overflow:auto; border:1px solid #ddd; padding:6px;">
  {html}
</div>
"""))

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# =========================
# Tourists (y) vs Time (x) — Belgium vs Luxembourg
# Pre: 2001–2006 (inclusive), Post: 2006–2009 (inclusive)
# Dashed vertical line at 2006
# =========================

countries_plot = ["Belgium", "Luxembourg"]
YEAR_MIN, YEAR_MAX = 2001, 2009
CUTOFF_YEAR = 2006

# --- detect columns robustly ---
country_col = next((c for c in df_DD.columns if c.strip().lower() == "country"), None)
year_col    = next((c for c in df_DD.columns if c.strip().lower() == "year"), None)
tour_col    = next((c for c in df_DD.columns if "tourist" in c.strip().lower()), None)

if country_col is None or year_col is None or tour_col is None:
    raise KeyError(f"Colonnes introuvables. Trouvé: country={country_col}, year={year_col}, tourists={tour_col}")

# --- subset + clean ---
d = df_DD[[country_col, year_col, tour_col]].copy()
d[year_col] = pd.to_numeric(d[year_col], errors="coerce")
d[tour_col] = pd.to_numeric(d[tour_col], errors="coerce")
d = d.dropna(subset=[country_col, year_col, tour_col])

# match names case-insensitive (safer)
name_map = {str(x).strip().lower(): str(x) for x in d[country_col].unique()}
picked = [name_map.get(c.lower()) for c in countries_plot]
if any(p is None for p in picked):
    missing = [countries_plot[i] for i,p in enumerate(picked) if p is None]
    raise KeyError(f"Pays introuvables dans le dataset: {missing}")

d = d[d[country_col].isin(picked)]
d = d[(d[year_col] >= YEAR_MIN) & (d[year_col] <= YEAR_MAX)].copy()
d[year_col] = d[year_col].astype(int)

# ensure continuous years on x for nicer lines
years = list(range(YEAR_MIN, YEAR_MAX + 1))
wide = (
    d.pivot(index=year_col, columns=country_col, values=tour_col)
     .reindex(years)
     .sort_index()
)

# --- plot ---
plt.figure(figsize=(11, 5.5))
for c in picked:
    plt.plot(wide.index, wide[c], marker="o", linewidth=2, label=c)

# pre/post shading (visual)
plt.axvspan(YEAR_MIN, CUTOFF_YEAR, alpha=0.08)
plt.axvspan(CUTOFF_YEAR, YEAR_MAX, alpha=0.14)

# cutoff line
plt.axvline(CUTOFF_YEAR, linestyle="--", linewidth=2)

plt.title("Tourists over time — Belgium vs Luxembourg (Pre/Post split at 2006)")
plt.xlabel("Year")
plt.ylabel("Tourists")
plt.xticks(years, rotation=0)
plt.grid(True, alpha=0.25)
plt.legend(frameon=True)
plt.tight_layout()
plt.show()

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# =========================
# MANY pair plots — same style as your Belgium/Luxembourg plot
# Rules:
# - pre starts at 2001
# - post ends at (disaster_year + 3)
# - dashed vertical line at disaster_year
# =========================

PRE_START = 2001

plots = [
    ("Belgium", "Austria", 2006),
    ("Brazil", "Urugay", 2011),
    ("Brazil", "Paraguay", 2011),
    ("Brazil", "Chile", 2011),
    ("Burkina Faso", "Egypt", 2007),
    ("Ethiopia", "Turkey", 2006),
    ("Ethiopia", "Mali", 2006),
    ("France", "Luxembourg", 2006),
    ("France", "Austria", 2006),
    ("Nepal", "Papua New Guinea", 2015),
    ("Netherlands", "Luxembourg", 2006),
    ("Netherland", "Sweden", 2006),
]

# --- detect columns robustly ---
country_col = next((c for c in df_DD.columns if c.strip().lower() == "country"), None)
year_col    = next((c for c in df_DD.columns if c.strip().lower() == "year"), None)
tour_col    = next((c for c in df_DD.columns if "tourist" in c.strip().lower()), None)

if country_col is None or year_col is None or tour_col is None:
    raise KeyError(f"Colonnes introuvables. Trouvé: country={country_col}, year={year_col}, tourists={tour_col}")

# --- base clean df ---
d0 = df_DD[[country_col, year_col, tour_col]].copy()
d0[year_col] = pd.to_numeric(d0[year_col], errors="coerce")
d0[tour_col] = pd.to_numeric(d0[tour_col], errors="coerce")
d0 = d0.dropna(subset=[country_col, year_col, tour_col])

# country name map (case-insensitive) + a few aliases for typos
name_map = {str(x).strip().lower(): str(x) for x in d0[country_col].unique()}
aliases = {
    "urugay": "uruguay",
    "netherland": "netherlands",
}

def resolve_country(name: str):
    key = name.strip().lower()
    key = aliases.get(key, key)
    return name_map.get(key, None)

def plot_pair(c1, c2, disaster_year):
    year_min = PRE_START
    year_max = int(disaster_year) + 3
    cutoff = int(disaster_year)

    r1 = resolve_country(c1)
    r2 = resolve_country(c2)
    if r1 is None or r2 is None:
        missing = [c for c, r in [(c1, r1), (c2, r2)] if r is None]
        print(f"SKIP: pays introuvable(s) dans le dataset: {missing}")
        return

    d = d0[d0[country_col].isin([r1, r2])].copy()
    d = d[(d[year_col] >= year_min) & (d[year_col] <= year_max)].copy()
    d[year_col] = d[year_col].astype(int)

    years = list(range(year_min, year_max + 1))
    wide = (
        d.pivot(index=year_col, columns=country_col, values=tour_col)
         .reindex(years)
         .sort_index()
    )

    # if both series are almost empty in that window, skip
    if wide[r1].notna().sum() < 2 or wide[r2].notna().sum() < 2:
        print(f"SKIP: pas assez de données (2001–{year_max}) pour {r1} vs {r2}")
        return

    plt.figure(figsize=(11, 5.5))
    plt.plot(wide.index, wide[r1], marker="o", linewidth=2, label=r1)
    plt.plot(wide.index, wide[r2], marker="o", linewidth=2, label=r2)

    # pre/post shading
    plt.axvspan(year_min, cutoff, alpha=0.08)
    plt.axvspan(cutoff, year_max, alpha=0.14)

    # cutoff line
    plt.axvline(cutoff, linestyle="--", linewidth=2)

    plt.title(f"Tourists over time — {r1} vs {r2} (Pre/Post split at {cutoff})")
    plt.xlabel("Year")
    plt.ylabel("Tourists")
    plt.xticks(years)
    plt.grid(True, alpha=0.25)
    plt.legend(frameon=True)
    plt.tight_layout()
    plt.show()

# --- run all plots ---
for c1, c2, dy in plots:
    plot_pair(c1, c2, dy)

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# =========================
# MANY pair plots — same style
# BUT y-axis = ln(tourists)
# Rules:
# - pre starts at 2001
# - post ends at (disaster_year + 3)
# - dashed vertical line at disaster_year
# =========================

PRE_START = 2001

plots = [
    ("Belgium", "Luxembourg", 2006),
    ("Belgique", "Austria", 2006),          # will be mapped to Belgium
    ("Brazil", "Urugay", 2011),              # typo -> Uruguay
    ("Brazil", "Paraguay", 2011),
    ("Brazil", "Chile", 2011),
    ("Burkina Faso", "Egypt", 2007),
    ("Ethiopia", "Turkey", 2006),
    ("Ethiopia", "Mali", 2006),
    ("France", "Luxembourg", 2006),
    ("France", "Austria", 2006),
    ("Nepal", "Papua New Guinea", 2015),
    ("Netherlands", "Luxembourg", 2006),
    ("Netherland", "Sweden", 2006),         # typo -> Netherlands
]

# --- detect columns robustly ---
country_col = next((c for c in df_DD.columns if c.strip().lower() == "country"), None)
year_col    = next((c for c in df_DD.columns if c.strip().lower() == "year"), None)
tour_col    = next((c for c in df_DD.columns if "tourist" in c.strip().lower()), None)

if country_col is None or year_col is None or tour_col is None:
    raise KeyError(f"Colonnes introuvables. Trouvé: country={country_col}, year={year_col}, tourists={tour_col}")

# --- base clean df ---
d0 = df_DD[[country_col, year_col, tour_col]].copy()
d0[year_col] = pd.to_numeric(d0[year_col], errors="coerce")
d0[tour_col] = pd.to_numeric(d0[tour_col], errors="coerce")
d0 = d0.dropna(subset=[country_col, year_col, tour_col])

# keep only strictly positive for ln
d0 = d0[d0[tour_col] > 0].copy()
d0["ln_tourists"] = np.log(d0[tour_col])

# country name map (case-insensitive) + aliases
name_map = {str(x).strip().lower(): str(x) for x in d0[country_col].unique()}
aliases = {
    "urugay": "uruguay",
    "netherland": "netherlands",
    "belgique": "belgium",
}

def resolve_country(name: str):
    key = name.strip().lower()
    key = aliases.get(key, key)
    return name_map.get(key, None)

def plot_pair_ln(c1, c2, disaster_year):
    year_min = PRE_START
    year_max = int(disaster_year) + 3
    cutoff = int(disaster_year)

    r1 = resolve_country(c1)
    r2 = resolve_country(c2)
    if r1 is None or r2 is None:
        missing = [c for c, r in [(c1, r1), (c2, r2)] if r is None]
        print(f"SKIP: pays introuvable(s) dans le dataset: {missing}")
        return

    d = d0[d0[country_col].isin([r1, r2])].copy()
    d = d[(d[year_col] >= year_min) & (d[year_col] <= year_max)].copy()
    d[year_col] = d[year_col].astype(int)

    years = list(range(year_min, year_max + 1))
    wide = (
        d.pivot(index=year_col, columns=country_col, values="ln_tourists")
         .reindex(years)
         .sort_index()
    )

    if wide[r1].notna().sum() < 2 or wide[r2].notna().sum() < 2:
        print(f"SKIP: pas assez de données (2001–{year_max}) pour {r1} vs {r2}")
        return

    plt.figure(figsize=(11, 5.5))
    plt.plot(wide.index, wide[r1], marker="o", linewidth=2, label=r1)
    plt.plot(wide.index, wide[r2], marker="o", linewidth=2, label=r2)

    # pre/post shading
    plt.axvspan(year_min, cutoff, alpha=0.08)
    plt.axvspan(cutoff, year_max, alpha=0.14)

    # cutoff line
    plt.axvline(cutoff, linestyle="--", linewidth=2)

    plt.title(f"ln(Tourists) over time — {r1} vs {r2} (Pre/Post split at {cutoff})")
    plt.xlabel("Year")
    plt.ylabel("ln(Tourists)")
    plt.xticks(years)
    plt.grid(True, alpha=0.25)
    plt.legend(frameon=True)
    plt.tight_layout()
    plt.show()

# --- run all plots ---
for c1, c2, dy in plots:
    plot_pair_ln(c1, c2, dy)

# =========================
# DiD (Belgium treated vs Luxembourg control), TWFE (country + year FE)
# Outcome: ln(tourists)
# Controls: ln(deaths+1), ln(wri_v+1), ln(pop_density), ln(gdp_pc)
# Window: 2001–2009, Post = year >= 2006  (so PRE = 2001–2005)
# =========================

import numpy as np
import pandas as pd

!pip install linearmodels
from linearmodels.panel import PanelOLS

# --- parameters ---
treated_country = "Belgium"
control_country = "Luxembourg"
YEAR_MIN, YEAR_MAX = 2001, 2009
CUTOFF_YEAR = 2006  # Post starts here

# --- columns (as you gave) ---
country_col = "country"
year_col = "year"
deaths_col = "deaths"
tour_col = "tourists ['000]"
wri_v_col = "wri_v"
popd_col = "pop_density"
gdp_col = "gdp_pc"

# --- subset ---
df_did = df_DD[df_DD[country_col].isin([treated_country, control_country])].copy()
df_did[year_col] = pd.to_numeric(df_did[year_col], errors="coerce")
df_did = df_did[(df_did[year_col] >= YEAR_MIN) & (df_did[year_col] <= YEAR_MAX)].copy()

# --- numeric ---
for c in [deaths_col, tour_col, wri_v_col, popd_col, gdp_col]:
    df_did[c] = pd.to_numeric(df_did[c], errors="coerce")

# --- logs (robust) ---
df_did["ln_tourists"] = np.where(df_did[tour_col] > 0, np.log(df_did[tour_col]), np.nan)
df_did["ln_deaths"] = np.log(df_did[deaths_col].fillna(0) + 1)                 # handles zeros
df_did["ln_wri_v"] = np.where(df_did[wri_v_col] >= 0, np.log(df_did[wri_v_col] + 1), np.nan)
df_did["ln_pop_density"] = np.where(df_did[popd_col] > 0, np.log(df_did[popd_col]), np.nan)
df_did["ln_gdp_pc"] = np.where(df_did[gdp_col] > 0, np.log(df_did[gdp_col]), np.nan)

# --- DiD dummies ---
df_did["treated"] = (df_did[country_col] == treated_country).astype(int)
df_did["post"] = (df_did[year_col] >= CUTOFF_YEAR).astype(int)
df_did["did"] = df_did["treated"] * df_did["post"]

# --- panel index ---
df_did = df_did.set_index([country_col, year_col])

# --- regression dataset ---
vars_needed = ["ln_tourists", "did", "ln_deaths", "ln_wri_v", "ln_pop_density", "ln_gdp_pc"]
df_reg = df_did[vars_needed].dropna().copy()

y = df_reg["ln_tourists"]
X = df_reg[["did", "ln_deaths", "ln_wri_v", "ln_pop_density", "ln_gdp_pc"]]

# --- TWFE DiD ---
res = PanelOLS(y, X, entity_effects=True, time_effects=True).fit(cov_type="robust")
print(res.summary)

print("nobs:", res.nobs)
print("df_resid:", res.df_resid)
print("R2 (within):", res.rsquared_within)
print("R2 (overall):", res.rsquared_overall)
print("Residual std:", float(res.resids.std()))
print("Nb countries:", df_reg.index.get_level_values(0).nunique())
print("Nb years:", df_reg.index.get_level_values(1).nunique())

import numpy as np
import pandas as pd
from linearmodels.panel import PanelOLS

# =========================
# DiD TWFE (country + year FE) with ROBUST SE, for many pairs
# Prints res.summary for EACH pair
# Outcome: ln(tourists)
# Controls: ln(deaths+1), ln(wri_v+1), ln(pop_density), ln(gdp_pc)
# Window: 2001 -> (disaster_year + 3), Post = year >= disaster_year
# =========================

# --- your column names ---
country_col = "country"
year_col    = "year"
deaths_col  = "deaths"
tour_col    = "tourists ['000]"
wri_v_col     = "wri_v"
popd_col    = "pop_density"
gdp_col     = "gdp_pc"

PRE_START = 2001
POST_YEARS = 4  # post includes disaster_year ... disaster_year+3

pairs = [
    ("Belgium", "Luxembourg", 2006),
    ("Belgique", "Austria", 2006),
    ("Brazil", "Urugay", 2011),
    ("Brazil", "Paraguay", 2011),
    ("Brazil", "Chile", 2011),
    ("Burkina Faso", "Egypt", 2007),
    ("Ethiopia", "Turkey", 2006),
    ("Ethiopia", "Mali", 2006),
    ("France", "Luxembourg", 2006),
    ("France", "Austria", 2006),
    ("Nepal", "Papua New Guinea", 2015),
    ("Netherlands", "Luxembourg", 2006),
    ("Netherland", "Sweden", 2006),
]

# aliases for typos / French names
aliases = {
    "belgique": "belgium",
    "urugay": "uruguay",
    "netherland": "netherlands",
}

# map dataset country names case-insensitively
name_map = {str(x).strip().lower(): str(x) for x in df_DD[country_col].dropna().unique()}

def resolve_country(name: str):
    k = name.strip().lower()
    k = aliases.get(k, k)
    return name_map.get(k, None)

def run_did_pair(treated_name, control_name, disaster_year):
    treated = resolve_country(treated_name)
    control = resolve_country(control_name)

    if treated is None or control is None:
        print("\n" + "="*100)
        print(f"SKIP: country not found | treated='{treated_name}' -> {treated} | control='{control_name}' -> {control}")
        print("="*100)
        return None

    year_min = PRE_START
    year_max = int(disaster_year) + (POST_YEARS - 1)

    df = df_DD[df_DD[country_col].isin([treated, control])].copy()
    df[year_col] = pd.to_numeric(df[year_col], errors="coerce")
    df = df[(df[year_col] >= year_min) & (df[year_col] <= year_max)].copy()

    for c in [deaths_col, tour_col, wri_v_col, popd_col, gdp_col]:
        df[c] = pd.to_numeric(df[c], errors="coerce")

    # logs
    df["ln_tourists"] = np.where(df[tour_col] > 0, np.log(df[tour_col]), np.nan)
    df["ln_deaths"] = np.log(df[deaths_col].fillna(0) + 1)
    df["ln_wri_v"] = np.where(df[wri_v_col] >= 0, np.log(df[wri_v_col] + 1), np.nan)
    df["ln_pop_density"] = np.where(df[popd_col] > 0, np.log(df[popd_col]), np.nan)
    df["ln_gdp_pc"] = np.where(df[gdp_col] > 0, np.log(df[gdp_col]), np.nan)

    # DiD dummies
    df["treated"] = (df[country_col] == treated).astype(int)
    df["post"] = (df[year_col] >= int(disaster_year)).astype(int)
    df["did"] = df["treated"] * df["post"]

    # panel index
    df = df.set_index([country_col, year_col])

    needed = ["ln_tourists", "did", "ln_deaths", "ln_wri_v", "ln_pop_density", "ln_gdp_pc"]
    reg = df[needed].dropna().copy()

    # sanity checks
    if reg.shape[0] < 6:
        print("\n" + "="*100)
        print(f"SKIP: not enough usable rows after dropna ({reg.shape[0]}) | {treated} vs {control} | window {year_min}-{year_max}")
        print("="*100)
        return None
    if reg.index.get_level_values(0).nunique() < 2:
        print("\n" + "="*100)
        print(f"SKIP: need 2 countries after dropna | {treated} vs {control}")
        print("="*100)
        return None
    if reg.index.get_level_values(1).nunique() < 4:
        print("\n" + "="*100)
        print(f"SKIP: need >=4 years after dropna | {treated} vs {control}")
        print("="*100)
        return None

    y = reg["ln_tourists"]
    X = reg[["did", "ln_deaths", "ln_wri_v", "ln_pop_density", "ln_gdp_pc"]]

    res = PanelOLS(y, X, entity_effects=True, time_effects=True).fit(cov_type="robust")

    print("\n" + "="*100)
    print(f"{treated} (treated) vs {control} (control) | disaster_year={int(disaster_year)} | window={year_min}-{year_max} | ROBUST SE")
    print("="*100)
    print(res.summary)

    return res

# --- run all pairs and print summaries ---
for t, c, dy in pairs:
    run_did_pair(t, c, dy)

import numpy as np
import pandas as pd
from IPython.display import display, HTML
from linearmodels.panel import PanelOLS

# =============================================================================
# DiD SUMMARY TABLE (same style): 13 TWFE DiD regressions (ROBUST SE)
# NO extra controls (only did + ln_deaths)
# Outcome: ln(tourists)
# Regressors: did, ln(deaths+1)
# FE: country + year
# Window: 2001 -> (disaster_year + 3), Post = year >= disaster_year
# =============================================================================

# =========================
# Helpers: stars + HTML cell
# =========================
def p_to_stars(p):
    if pd.isna(p): return ""
    if p < 0.01: return "***"
    if p < 0.05: return "**"
    if p < 0.10: return "*"
    return ""

def format_cell_html(coef, se, p, digits=4):
    if pd.isna(coef):
        return ""
    return f"{coef:.{digits}f}{p_to_stars(p)}<br><span style='font-size:12px;'>({se:.{digits}f})</span>"

def display_html_table(df_table):
    html = df_table.to_html(escape=False, border=0)
    html = f"""
    <div style="max-width: 100%; overflow-x: auto;">
      <style>
        table {{ border-collapse: collapse; font-family: Arial, sans-serif; font-size: 14px; }}
        th, td {{ border: 1px solid #ddd; padding: 8px; vertical-align: top; text-align: center; }}
        th {{ background: #f5f5f5; font-weight: 700; }}
        td:first-child, th:first-child {{ text-align: left; font-weight: 700; }}
      </style>
      {html}
    </div>
    """
    display(HTML(html))

# =========================
# Data + columns
# =========================
country_col = "country"
year_col    = "year"
deaths_col  = "deaths"
tour_col    = "tourists ['000]"

required = [country_col, year_col, deaths_col, tour_col]
missing_cols = [c for c in required if c not in df_DD.columns]
if missing_cols:
    raise KeyError(f"Missing columns in df_DD: {missing_cols}")

PRE_START = 2001
POST_YEARS = 4  # disaster_year ... disaster_year+3

pairs = [
    ("Belgium", "Luxembourg", 2006),
    ("Belgique", "Austria", 2006),
    ("Brazil", "Urugay", 2011),
    ("Brazil", "Paraguay", 2011),
    ("Brazil", "Chile", 2011),
    ("Burkina Faso", "Egypt", 2007),
    ("Ethiopia", "Turkey", 2006),
    ("Ethiopia", "Mali", 2006),
    ("France", "Luxembourg", 2006),
    ("France", "Austria", 2006),
    ("Nepal", "Papua New Guinea", 2015),
    ("Netherlands", "Luxembourg", 2006),
    ("Netherland", "Sweden", 2006),
]

aliases = {
    "belgique": "belgium",
    "urugay": "uruguay",
    "netherland": "netherlands",
}

name_map = {str(x).strip().lower(): str(x) for x in df_DD[country_col].dropna().unique()}

def resolve_country(name: str):
    k = name.strip().lower()
    k = aliases.get(k, k)
    return name_map.get(k, None)

# =========================
# Fit DiD for one pair (ROBUST SE)
# =========================
def fit_did_pair(treated_input, control_input, disaster_year):
    treated = resolve_country(treated_input)
    control = resolve_country(control_input)

    if treated is None or control is None:
        return None, {
            "status": "SKIP (country not found)",
            "treated": treated_input, "control": control_input,
            "disaster_year": int(disaster_year),
            "window": "",
            "nobs": "", "countries": "", "years": "",
            "r2w": "", "country_fe": "", "year_fe": "", "se": ""
        }

    year_min = PRE_START
    year_max = int(disaster_year) + (POST_YEARS - 1)

    df = df_DD[df_DD[country_col].isin([treated, control])].copy()
    df[year_col] = pd.to_numeric(df[year_col], errors="coerce")
    df = df[(df[year_col] >= year_min) & (df[year_col] <= year_max)].copy()

    df[deaths_col] = pd.to_numeric(df[deaths_col], errors="coerce")
    df[tour_col]   = pd.to_numeric(df[tour_col], errors="coerce")

    # logs
    df["ln_tourists"] = np.where(df[tour_col] > 0, np.log(df[tour_col]), np.nan)
    df["ln_deaths"]   = np.log(df[deaths_col].fillna(0) + 1)

    # DiD dummies
    df["treated"] = (df[country_col] == treated).astype(int)
    df["post"] = (df[year_col] >= int(disaster_year)).astype(int)
    df["did"] = df["treated"] * df["post"]

    df = df.set_index([country_col, year_col])

    needed = ["ln_tourists", "did", "ln_deaths"]
    reg = df[needed].dropna().copy()

    if reg.shape[0] < 6 or reg.index.get_level_values(0).nunique() < 2 or reg.index.get_level_values(1).nunique() < 4:
        return None, {
            "status": "SKIP (not enough usable data after dropna)",
            "treated": treated, "control": control,
            "disaster_year": int(disaster_year),
            "window": f"{year_min}-{year_max}",
            "nobs": str(reg.shape[0]),
            "countries": str(reg.index.get_level_values(0).nunique()),
            "years": str(reg.index.get_level_values(1).nunique()),
            "r2w": "", "country_fe": "", "year_fe": "", "se": ""
        }

    y = reg["ln_tourists"]
    X = reg[["did", "ln_deaths"]]

    res = PanelOLS(y, X, entity_effects=True, time_effects=True).fit(cov_type="robust")

    idx = reg.index
    meta = {
        "status": "OK",
        "treated": treated,
        "control": control,
        "disaster_year": int(disaster_year),
        "window": f"{year_min}-{year_max}",
        "nobs": str(int(res.nobs)),
        "countries": str(idx.get_level_values(0).nunique()),
        "years": str(idx.get_level_values(1).nunique()),
        "r2w": "" if getattr(res, "rsquared_within", None) is None else f"{res.rsquared_within:.4f}",
        "country_fe": "Yes",
        "year_fe": "Yes",
        "se": "Robust"
    }
    return res, meta

# =========================
# Fit all models
# =========================
models = []
metas = []
col_names = []

for t, c, dy in pairs:
    res, meta = fit_did_pair(t, c, dy)
    models.append(res)
    metas.append(meta)
    if meta["status"] == "OK":
        col_names.append(f"{meta['treated']} vs {meta['control']} (D={meta['disaster_year']})")
    else:
        col_names.append(f"{t} vs {c} (D={int(dy)})")

# =========================
# Build table (same style)
# =========================
rows = ["did", "ln_deaths"]
pretty = {
    "did": "DiD (Treated × Post)",
    "ln_deaths": "ln(Deaths + 1)",
}

table = pd.DataFrame(index=[pretty[r] for r in rows], columns=col_names, dtype=object)

Ns, r2w_list = [], []
country_FE_flags, year_FE_flags, se_type_list = [], [], []
entities_list, periods_list = [], []
window_list, status_list = [], []
disaster_list, treated_list, control_list = [], [], []

for res, meta, cname in zip(models, metas, col_names):
    status_list.append(meta.get("status", ""))
    treated_list.append(meta.get("treated", ""))
    control_list.append(meta.get("control", ""))
    disaster_list.append(str(meta.get("disaster_year", "")))
    window_list.append(meta.get("window", ""))

    Ns.append(meta.get("nobs", ""))
    entities_list.append(meta.get("countries", ""))
    periods_list.append(meta.get("years", ""))
    r2w_list.append(meta.get("r2w", ""))

    country_FE_flags.append(meta.get("country_fe", ""))
    year_FE_flags.append(meta.get("year_fe", ""))
    se_type_list.append(meta.get("se", ""))

    if res is None:
        for r in rows:
            table.loc[pretty[r], cname] = ""
        continue

    params = res.params
    ses    = res.std_errors
    pvals  = res.pvalues

    for r in rows:
        table.loc[pretty[r], cname] = format_cell_html(
            params.get(r, np.nan),
            ses.get(r, np.nan),
            pvals.get(r, np.nan),
            digits=4
        )

info = pd.DataFrame(
    index=[
        "Status",
        "Treated",
        "Control",
        "Disaster year (cutoff)",
        "Window",
        "N",
        "# Countries",
        "# Years",
        "R² within (FE)",
        "Country FE",
        "Year FE",
        "SE",
    ],
    columns=col_names,
    dtype=object
)
info.loc["Status"] = status_list
info.loc["Treated"] = treated_list
info.loc["Control"] = control_list
info.loc["Disaster year (cutoff)"] = disaster_list
info.loc["Window"] = window_list
info.loc["N"] = Ns
info.loc["# Countries"] = entities_list
info.loc["# Years"] = periods_list
info.loc["R² within (FE)"] = r2w_list
info.loc["Country FE"] = country_FE_flags
info.loc["Year FE"] = year_FE_flags
info.loc["SE"] = se_type_list

final_table = pd.concat([table, info], axis=0)

# =========================
# Render HTML
# =========================
display_html_table(final_table)

import numpy as np
import pandas as pd
from IPython.display import display, HTML
from linearmodels.panel import PanelOLS

# =============================================================================
# DiD SUMMARY TABLE (same style): 3 TWFE DiD regressions (ROBUST SE)
# NO extra controls (only did + ln_deaths)
# Outcome: ln(tourists)
# Regressors: did, ln(deaths+1)
# FE: country + year
# Window: 2001 -> (disaster_year + 3), Post = year >= disaster_year
#
# 1) Treated = Brazil,      Controls = Uruguay + Paraguay,   Disaster year = 2011
# 2) Treated = Netherlands, Controls = Luxembourg + Sweden,  Disaster year = 2006
# 3) Treated = Belgium,     Controls = Luxembourg + Austria, Disaster year = 2006
# =============================================================================

# =========================
# Helpers: stars + HTML cell
# =========================
def p_to_stars(p):
    if pd.isna(p): return ""
    if p < 0.01: return "***"
    if p < 0.05: return "**"
    if p < 0.10: return "*"
    return ""

def format_cell_html(coef, se, p, digits=4):
    if pd.isna(coef):
        return ""
    return f"{coef:.{digits}f}{p_to_stars(p)}<br><span style='font-size:12px;'>({se:.{digits}f})</span>"

def display_html_table(df_table):
    html = df_table.to_html(escape=False, border=0)
    html = f"""
    <div style="max-width: 100%; overflow-x: auto;">
      <style>
        table {{ border-collapse: collapse; font-family: Arial, sans-serif; font-size: 14px; }}
        th, td {{ border: 1px solid #ddd; padding: 8px; vertical-align: top; text-align: center; }}
        th {{ background: #f5f5f5; font-weight: 700; }}
        td:first-child, th:first-child {{ text-align: left; font-weight: 700; }}
      </style>
      {html}
    </div>
    """
    display(HTML(html))

# =========================
# Data + columns
# =========================
country_col = "country"
year_col    = "year"
deaths_col  = "deaths"
tour_col    = "tourists ['000]"

required = [country_col, year_col, deaths_col, tour_col]
missing_cols = [c for c in required if c not in df_DD.columns]
if missing_cols:
    raise KeyError(f"Missing columns in df_DD: {missing_cols}")

PRE_START = 2001
POST_YEARS = 4  # disaster_year ... disaster_year+3

# 3 multi-control DiDs
specs = [
    ("Brazil",      ["Uruguay", "Paraguay"],     2011),
    ("Netherlands", ["Luxembourg", "Sweden"],    2006),
    ("Belgium",     ["Luxembourg", "Austria"],   2006),
]

aliases = {
    "belgique": "belgium",
    "urugay": "uruguay",
    "netherland": "netherlands",
}

name_map = {str(x).strip().lower(): str(x) for x in df_DD[country_col].dropna().unique()}

def resolve_country(name: str):
    k = name.strip().lower()
    k = aliases.get(k, k)
    return name_map.get(k, None)

# =========================
# Fit DiD for one treated vs multiple controls (ROBUST SE)
# =========================
def fit_did_multi(treated_input, controls_input_list, disaster_year):
    treated = resolve_country(treated_input)
    controls = [resolve_country(c) for c in controls_input_list]

    if treated is None or any(c is None for c in controls):
        missing = []
        if treated is None: missing.append(f"treated='{treated_input}'")
        for raw, resolved in zip(controls_input_list, controls):
            if resolved is None:
                missing.append(f"control='{raw}'")
        return None, {
            "status": f"SKIP (country not found: {', '.join(missing)})",
            "treated": treated_input,
            "controls": ", ".join(controls_input_list),
            "disaster_year": int(disaster_year),
            "window": "",
            "nobs": "", "countries": "", "years": "",
            "r2w": "", "country_fe": "", "year_fe": "", "se": ""
        }

    year_min = PRE_START
    year_max = int(disaster_year) + (POST_YEARS - 1)

    keep_countries = [treated] + controls

    df = df_DD[df_DD[country_col].isin(keep_countries)].copy()
    df[year_col] = pd.to_numeric(df[year_col], errors="coerce")
    df = df[(df[year_col] >= year_min) & (df[year_col] <= year_max)].copy()

    df[deaths_col] = pd.to_numeric(df[deaths_col], errors="coerce")
    df[tour_col]   = pd.to_numeric(df[tour_col], errors="coerce")

    # logs
    df["ln_tourists"] = np.where(df[tour_col] > 0, np.log(df[tour_col]), np.nan)
    df["ln_deaths"]   = np.log(df[deaths_col].fillna(0) + 1)

    # DiD dummies (treated vs pooled controls)
    df["treated"] = (df[country_col] == treated).astype(int)
    df["post"] = (df[year_col] >= int(disaster_year)).astype(int)
    df["did"] = df["treated"] * df["post"]

    df = df.set_index([country_col, year_col])

    needed = ["ln_tourists", "did", "ln_deaths"]
    reg = df[needed].dropna().copy()

    if reg.shape[0] < 8 or reg.index.get_level_values(0).nunique() < 2 or reg.index.get_level_values(1).nunique() < 4:
        return None, {
            "status": "SKIP (not enough usable data after dropna)",
            "treated": treated,
            "controls": ", ".join(controls),
            "disaster_year": int(disaster_year),
            "window": f"{year_min}-{year_max}",
            "nobs": str(reg.shape[0]),
            "countries": str(reg.index.get_level_values(0).nunique()),
            "years": str(reg.index.get_level_values(1).nunique()),
            "r2w": "", "country_fe": "", "year_fe": "", "se": ""
        }

    y = reg["ln_tourists"]
    X = reg[["did", "ln_deaths"]]

    res = PanelOLS(y, X, entity_effects=True, time_effects=True).fit(cov_type="robust")

    idx = reg.index
    meta = {
        "status": "OK",
        "treated": treated,
        "controls": ", ".join(controls),
        "disaster_year": int(disaster_year),
        "window": f"{year_min}-{year_max}",
        "nobs": str(int(res.nobs)),
        "countries": str(idx.get_level_values(0).nunique()),
        "years": str(idx.get_level_values(1).nunique()),
        "r2w": "" if getattr(res, "rsquared_within", None) is None else f"{res.rsquared_within:.4f}",
        "country_fe": "Yes",
        "year_fe": "Yes",
        "se": "Robust"
    }
    return res, meta

# =========================
# Fit the 3 models
# =========================
models, metas, col_names = [], [], []

for treated, controls, dy in specs:
    res, meta = fit_did_multi(treated, controls, dy)
    models.append(res); metas.append(meta)
    col_names.append(f"{treated} vs ({', '.join(controls)}) (D={int(dy)})")

# =========================
# Build table (same style)
# =========================
rows = ["did", "ln_deaths"]
pretty = {
    "did": "DiD (Treated × Post)",
    "ln_deaths": "ln(Deaths + 1)",
}

table = pd.DataFrame(index=[pretty[r] for r in rows], columns=col_names, dtype=object)

Ns, r2w_list = [], []
country_FE_flags, year_FE_flags, se_type_list = [], [], []
entities_list, periods_list = [], []
window_list, status_list = [], []
disaster_list, treated_list, controls_list = [], [], []

for res, meta, cname in zip(models, metas, col_names):
    status_list.append(meta.get("status", ""))
    treated_list.append(meta.get("treated", ""))
    controls_list.append(meta.get("controls", ""))
    disaster_list.append(str(meta.get("disaster_year", "")))
    window_list.append(meta.get("window", ""))

    Ns.append(meta.get("nobs", ""))
    entities_list.append(meta.get("countries", ""))
    periods_list.append(meta.get("years", ""))
    r2w_list.append(meta.get("r2w", ""))

    country_FE_flags.append(meta.get("country_fe", ""))
    year_FE_flags.append(meta.get("year_fe", ""))
    se_type_list.append(meta.get("se", ""))

    if res is None:
        for r in rows:
            table.loc[pretty[r], cname] = ""
        continue

    params = res.params
    ses    = res.std_errors
    pvals  = res.pvalues

    for r in rows:
        table.loc[pretty[r], cname] = format_cell_html(
            params.get(r, np.nan),
            ses.get(r, np.nan),
            pvals.get(r, np.nan),
            digits=4
        )

info = pd.DataFrame(
    index=[
        "Status",
        "Treated",
        "Controls (pooled)",
        "Disaster year (cutoff)",
        "Window",
        "N",
        "# Countries",
        "# Years",
        "R² within (FE)",
        "Country FE",
        "Year FE",
        "SE",
    ],
    columns=col_names,
    dtype=object
)
info.loc["Status"] = status_list
info.loc["Treated"] = treated_list
info.loc["Controls (pooled)"] = controls_list
info.loc["Disaster year (cutoff)"] = disaster_list
info.loc["Window"] = window_list
info.loc["N"] = Ns
info.loc["# Countries"] = entities_list
info.loc["# Years"] = periods_list
info.loc["R² within (FE)"] = r2w_list
info.loc["Country FE"] = country_FE_flags
info.loc["Year FE"] = year_FE_flags
info.loc["SE"] = se_type_list

final_table = pd.concat([table, info], axis=0)

# =========================
# Render HTML
# =========================
display_html_table(final_table)

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from IPython.display import display, HTML
from linearmodels.panel import PanelOLS

# =============================================================================
# ROBUSTNESS CHECKS (2 cases):
# 1) Brazil (treated) vs Uruguay + Paraguay (controls), D=2011
# 2) Netherlands (treated) vs Luxembourg + Sweden (controls), D=2006
#
# Outputs:
# (1) Event-study figure (pre/post)
# (2) Table: Different control groups
# (3) Table: Different windows
#
# Model base:
# ln_tourists ~ did + ln_deaths + FE(country) + FE(year)
# SE: robust (HC)
# =============================================================================

# -------------------------
# Helpers (HTML tables)
# -------------------------
def p_to_stars(p):
    if pd.isna(p): return ""
    if p < 0.01: return "***"
    if p < 0.05: return "**"
    if p < 0.10: return "*"
    return ""

def format_cell_html(coef, se, p, digits=4):
    if pd.isna(coef):
        return ""
    return f"{coef:.{digits}f}{p_to_stars(p)}<br><span style='font-size:12px;'>({se:.{digits}f})</span>"

def display_html_table(df_table):
    html = df_table.to_html(escape=False, border=0)
    html = f"""
    <div style="max-width: 100%; overflow-x: auto;">
      <style>
        table {{ border-collapse: collapse; font-family: Arial, sans-serif; font-size: 14px; }}
        th, td {{ border: 1px solid #ddd; padding: 8px; vertical-align: top; text-align: center; }}
        th {{ background: #f5f5f5; font-weight: 700; }}
        td:first-child, th:first-child {{ text-align: left; font-weight: 700; }}
      </style>
      {html}
    </div>
    """
    display(HTML(html))

# -------------------------
# Columns
# -------------------------
country_col = "country"
year_col    = "year"
deaths_col  = "deaths"
tour_col    = "tourists ['000]"

required = [country_col, year_col, deaths_col, tour_col]
missing_cols = [c for c in required if c not in df_DD.columns]
if missing_cols:
    raise KeyError(f"Missing columns in df_DD: {missing_cols}")

# -------------------------
# Name resolution (typos/aliases)
# -------------------------
aliases = {
    "urugay": "uruguay",
    "netherland": "netherlands",
    "belgique": "belgium",
}
name_map = {str(x).strip().lower(): str(x) for x in df_DD[country_col].dropna().unique()}

def resolve_country(name: str):
    k = name.strip().lower()
    k = aliases.get(k, k)
    return name_map.get(k, None)

# =============================================================================
# Core: build clean panel for a treated + controls + window
# =============================================================================
def build_panel(treated_input, controls_input_list, disaster_year, year_min, year_max):
    treated = resolve_country(treated_input)
    controls = [resolve_country(c) for c in controls_input_list]

    if treated is None or any(c is None for c in controls):
        missing = []
        if treated is None: missing.append(f"treated='{treated_input}'")
        for raw, rr in zip(controls_input_list, controls):
            if rr is None: missing.append(f"control='{raw}'")
        return None, None, f"Country not found: {', '.join(missing)}"

    keep = [treated] + controls
    df = df_DD[df_DD[country_col].isin(keep)].copy()

    df[year_col] = pd.to_numeric(df[year_col], errors="coerce")
    df = df[(df[year_col] >= int(year_min)) & (df[year_col] <= int(year_max))].copy()

    df[deaths_col] = pd.to_numeric(df[deaths_col], errors="coerce")
    df[tour_col]   = pd.to_numeric(df[tour_col], errors="coerce")

    df["ln_tourists"] = np.where(df[tour_col] > 0, np.log(df[tour_col]), np.nan)
    df["ln_deaths"]   = np.log(df[deaths_col].fillna(0) + 1)

    df["treated"] = (df[country_col] == treated).astype(int)
    df["post"]    = (df[year_col] >= int(disaster_year)).astype(int)
    df["did"]     = df["treated"] * df["post"]

    df = df.set_index([country_col, year_col]).sort_index()
    return df, {"treated": treated, "controls": controls, "D": int(disaster_year)}, None

# =============================================================================
# (1) Event-study
# =============================================================================
def event_study_plot(treated, controls, D, pre_start=2001, post_years=4, K_pre=5, K_post=3, baseline=-1):
    year_min = pre_start
    year_max = int(D) + (int(post_years) - 1)

    df, meta, err = build_panel(treated, controls, D, year_min, year_max)
    if err is not None:
        print(f"[Event-study SKIP] {treated} vs {controls} (D={D}) -> {err}")
        return

    d = df[["ln_tourists","ln_deaths","treated"]].dropna().copy().reset_index()
    d["event_time"] = d[year_col].astype(int) - int(D)

    # keep only event_time in [-K_pre, K_post]
    d = d[(d["event_time"] >= -K_pre) & (d["event_time"] <= K_post)].copy()

    # Build interacted dummies: treated * 1[event_time==k], excluding baseline k
    event_cols = []
    for k in range(-K_pre, K_post + 1):
        if k == baseline:
            continue
        col = f"evt_{k}"
        d[col] = ((d["event_time"] == k).astype(int) * d["treated"]).astype(int)
        event_cols.append(col)

    # Panel index
    d = d.set_index([country_col, year_col]).sort_index()

    needed = ["ln_tourists", "ln_deaths"] + event_cols
    reg = d[needed].dropna().copy()
    if reg.shape[0] < 10 or reg.index.get_level_values(0).nunique() < 2:
        print(f"[Event-study SKIP] Not enough data after dropna for {meta['treated']} vs {meta['controls']} (D={D})")
        return

    y = reg["ln_tourists"]
    X = reg[event_cols + ["ln_deaths"]]

    res = PanelOLS(y, X, entity_effects=True, time_effects=True).fit(cov_type="robust")

    # Extract betas for event-time only
    coefs, ses = [], []
    ks = []
    for k in range(-K_pre, K_post + 1):
        if k == baseline:
            continue
        col = f"evt_{k}"
        if col in res.params.index:
            ks.append(k)
            coefs.append(float(res.params[col]))
            ses.append(float(res.std_errors[col]))

    coefs = np.array(coefs, dtype=float)
    ses   = np.array(ses, dtype=float)
    ci_lo = coefs - 1.96 * ses
    ci_hi = coefs + 1.96 * ses

    # Plot
    plt.figure(figsize=(10.5, 5.2))
    plt.axhline(0, linewidth=1)
    plt.axvline(0, linestyle="--", linewidth=2)  # event year
    plt.plot(ks, coefs, marker="o", linewidth=2)
    plt.fill_between(ks, ci_lo, ci_hi, alpha=0.2)

    plt.title(f"Event-study — {meta['treated']} vs {', '.join(meta['controls'])} (D={meta['D']}, baseline k={baseline})")
    plt.xlabel("Event time (year - D)")
    plt.ylabel("Effect on ln(tourists)")
    plt.xticks(range(-K_pre, K_post + 1))
    plt.grid(True, alpha=0.25)
    plt.tight_layout()
    plt.show()

    print(res.summary)

# =============================================================================
# (2) Table: Different control groups (same window)
# =============================================================================
def did_one_spec(treated, controls, D, pre_start=2001, post_years=4):
    year_min = pre_start
    year_max = int(D) + (int(post_years) - 1)

    df, meta, err = build_panel(treated, controls, D, year_min, year_max)
    if err is not None:
        return None, {"status": f"SKIP ({err})", "treated": treated, "controls": ", ".join(controls), "D": int(D),
                      "window": f"{year_min}-{year_max}", "nobs":"", "countries":"", "years":"", "r2w":"", "se":"", "fe":"Yes/Yes"}

    reg = df[["ln_tourists","did","ln_deaths"]].dropna().copy()
    if reg.shape[0] < 8 or reg.index.get_level_values(0).nunique() < 2 or reg.index.get_level_values(1).nunique() < 4:
        return None, {"status": "SKIP (not enough data after dropna)", "treated": meta["treated"],
                      "controls": ", ".join(meta["controls"]), "D": meta["D"], "window": f"{year_min}-{year_max}",
                      "nobs": str(reg.shape[0]), "countries": str(reg.index.get_level_values(0).nunique()),
                      "years": str(reg.index.get_level_values(1).nunique()), "r2w":"", "se":"Robust", "fe":"Yes/Yes"}

    y = reg["ln_tourists"]
    X = reg[["did","ln_deaths"]]
    res = PanelOLS(y, X, entity_effects=True, time_effects=True).fit(cov_type="robust")

    meta_out = {
        "status": "OK",
        "treated": meta["treated"],
        "controls": ", ".join(meta["controls"]),
        "D": meta["D"],
        "window": f"{year_min}-{year_max}",
        "nobs": str(int(res.nobs)),
        "countries": str(reg.index.get_level_values(0).nunique()),
        "years": str(reg.index.get_level_values(1).nunique()),
        "r2w": "" if getattr(res, "rsquared_within", None) is None else f"{res.rsquared_within:.4f}",
        "se": "Robust",
        "fe": "Yes/Yes",
    }
    return res, meta_out

def table_different_controls(title, treated, D, control_sets, pre_start=2001, post_years=4):
    models, metas, cols = [], [], []
    for controls in control_sets:
        res, meta = did_one_spec(treated, controls, D, pre_start=pre_start, post_years=post_years)
        models.append(res); metas.append(meta)
        cols.append(f"{treated} vs ({', '.join(controls)})")

    rows = ["did", "ln_deaths"]
    pretty = {"did": "DiD (Treated × Post)", "ln_deaths": "ln(Deaths + 1)"}
    table = pd.DataFrame(index=[pretty[r] for r in rows], columns=cols, dtype=object)

    status_list, window_list, Ns, ctry_list, yrs_list, r2w_list, se_list = [], [], [], [], [], [], []
    for res, meta, cname in zip(models, metas, cols):
        status_list.append(meta["status"])
        window_list.append(meta["window"])
        Ns.append(meta["nobs"])
        ctry_list.append(meta["countries"])
        yrs_list.append(meta["years"])
        r2w_list.append(meta["r2w"])
        se_list.append(meta["se"])

        if res is None:
            for r in rows: table.loc[pretty[r], cname] = ""
        else:
            for r in rows:
                table.loc[pretty[r], cname] = format_cell_html(
                    res.params.get(r, np.nan),
                    res.std_errors.get(r, np.nan),
                    res.pvalues.get(r, np.nan),
                    digits=4
                )

    info = pd.DataFrame(
        index=["Status","Window","N","# Countries","# Years","R² within (FE)","FE (country/year)","SE"],
        columns=cols, dtype=object
    )
    info.loc["Status"] = status_list
    info.loc["Window"] = window_list
    info.loc["N"] = Ns
    info.loc["# Countries"] = ctry_list
    info.loc["# Years"] = yrs_list
    info.loc["R² within (FE)"] = r2w_list
    info.loc["FE (country/year)"] = ["Yes / Yes"] * len(cols)
    info.loc["SE"] = se_list

    final = pd.concat([table, info], axis=0)
    print(f"\n=== {title} ===")
    display_html_table(final)

# =============================================================================
# (3) Table: Different windows (fixed control set)
# =============================================================================
def table_different_windows(title, treated, controls, D, window_specs):
    # window_specs: list of tuples (pre_start, post_years)
    models, metas, cols = [], [], []
    for pre_start, post_years in window_specs:
        res, meta = did_one_spec(treated, controls, D, pre_start=pre_start, post_years=post_years)
        models.append(res); metas.append(meta)
        cols.append(f"pre={pre_start}, post={post_years}y")

    rows = ["did", "ln_deaths"]
    pretty = {"did": "DiD (Treated × Post)", "ln_deaths": "ln(Deaths + 1)"}
    table = pd.DataFrame(index=[pretty[r] for r in rows], columns=cols, dtype=object)

    status_list, window_list, Ns, ctry_list, yrs_list, r2w_list, se_list = [], [], [], [], [], [], []
    for res, meta, cname in zip(models, metas, cols):
        status_list.append(meta["status"])
        window_list.append(meta["window"])
        Ns.append(meta["nobs"])
        ctry_list.append(meta["countries"])
        yrs_list.append(meta["years"])
        r2w_list.append(meta["r2w"])
        se_list.append(meta["se"])

        if res is None:
            for r in rows: table.loc[pretty[r], cname] = ""
        else:
            for r in rows:
                table.loc[pretty[r], cname] = format_cell_html(
                    res.params.get(r, np.nan),
                    res.std_errors.get(r, np.nan),
                    res.pvalues.get(r, np.nan),
                    digits=4
                )

    info = pd.DataFrame(
        index=["Status","Window","N","# Countries","# Years","R² within (FE)","FE (country/year)","SE"],
        columns=cols, dtype=object
    )
    info.loc["Status"] = status_list
    info.loc["Window"] = window_list
    info.loc["N"] = Ns
    info.loc["# Countries"] = ctry_list
    info.loc["# Years"] = yrs_list
    info.loc["R² within (FE)"] = r2w_list
    info.loc["FE (country/year)"] = ["Yes / Yes"] * len(cols)
    info.loc["SE"] = se_list

    final = pd.concat([table, info], axis=0)
    print(f"\n=== {title} ===")
    display_html_table(final)

# =============================================================================
# RUN: Brazil + Netherlands
# =============================================================================

# -------------------------
# (A) BRAZIL — D=2011
# -------------------------
treated_A = "Brazil"
controls_A_main = ["Uruguay","Paraguay"]
D_A = 2011

# 1) Event-study figure
event_study_plot(treated_A, controls_A_main, D_A, pre_start=2001, post_years=4, K_pre=8, K_post=3, baseline=-1)

# 2) Different control groups
control_sets_A = [
    ["Uruguay"],
    ["Paraguay"],
    ["Uruguay","Paraguay"],
]
table_different_controls(
    title="Different control groups — Brazil (D=2011)",
    treated=treated_A, D=D_A,
    control_sets=control_sets_A,
    pre_start=2001, post_years=4
)

# 3) Different windows
window_specs_A = [
    (2001, 3),  # post: D..D+2
    (2001, 4),  # post: D..D+3
    (2001, 6),  # post: D..D+5
    (2003, 4),
    (2005, 4),
]
table_different_windows(
    title="Different windows — Brazil vs (Uruguay+Paraguay) (D=2011)",
    treated=treated_A, controls=controls_A_main, D=D_A,
    window_specs=window_specs_A
)

# -------------------------
# (B) NETHERLANDS — D=2006
# -------------------------
treated_B = "Netherlands"
controls_B_main = ["Luxembourg","Sweden"]
D_B = 2006

# 1) Event-study figure
event_study_plot(treated_B, controls_B_main, D_B, pre_start=2001, post_years=4, K_pre=5, K_post=3, baseline=-1)

# 2) Different control groups
control_sets_B = [
    ["Luxembourg"],
    ["Sweden"],
    ["Luxembourg","Sweden"],
]
table_different_controls(
    title="Different control groups — Netherlands (D=2006)",
    treated=treated_B, D=D_B,
    control_sets=control_sets_B,
    pre_start=2001, post_years=4
)

# 3) Different windows
window_specs_B = [
    (2001, 3),
    (2001, 4),
    (2001, 6),
    (2002, 4),
    (2003, 4),
]
table_different_windows(
    title="Different windows — Netherlands vs (Luxembourg+Sweden) (D=2006)",
    treated=treated_B, controls=controls_B_main, D=D_B,
    window_specs=window_specs_B
)